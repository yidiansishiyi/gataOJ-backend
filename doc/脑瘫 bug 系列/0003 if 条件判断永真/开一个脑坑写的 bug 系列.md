# 开一个脑坑写的 bug 系列

> 今天写了个 bug 前后测试几次反馈回来的数据都不对, 10 分钟的测试我都怀疑是我的编译器出了问题, 前两天弄个了 23.2 版本的 idea 貌似和某些插件不适配不能保存,对那天我写了一下午的代码都没了 哭死 / . 所以在我怀疑我用了5 个月的编译器后突然灵光一现,然后找到了问题的来源 , 所以打算开一个脑瘫系类的 bug 并从中找到自己的编程问题, 更改自己的编程习惯 . 

## BUG 编号 0003 if 判断句永远被判定为真

##### BUG 复述

校验用户 id 和 数据库写入数据的写入者 id 是否一致 , 如果不是校验其是否为管理员 , 如果两项校验都不通过则判定用户没有该返回数据的某一项的权限写入空值返回.

##### 上源代码

```java
    @Override
    public QuestionSubmitVO getQuestionSubmitVOPage(QuestionSubmit questionSubmit, User loginUser) {
        QuestionSubmitVO questionSubmitVO = QuestionSubmitVO.objToVo(questionSubmit);
        if (questionSubmit.getUserId() != loginUser.getId() && !userService.isAdmin(loginUser)) {
            questionSubmitVO.setCode(null);
        }
        return questionSubmitVO;
    }
```

第一眼看就是判断传入的登录对象的 id 和 需要脱敏的数据的 id 对比 , 如果 id 不同则再调用一个方法判断其是不是管理员,当两次判断都没过之后就进行空值写入 .

但是,接口测试时发现,无论什么条件,返回的数据该条数据都是脱敏过的 . ` questionSubmitVO.setCode(null);` 总是被执行 . 断点调试后发现这两个 id 数值是一样的, 所以当时以为是另一个实现出了问题,看了代码逻辑后确认后一部分没有问题,移除该判断后,发现前一层判断永远为真,陷入了深思,我不懂两个 long 类型的 id 比对用 `!=` 会有什么问题 , 莫不是我编译器发抽 .等等突然发现了华点 .

##### BUG 产生原因复现

```
/**
 * 创建用户 id
 */
private Long userId;
```

```
@TableId(type = IdType.ASSIGN_ID)
private Long id;
```

这是两个 ID 的具体代码 , 如果看到这还没有意识到问题那就说明基础有问题了 . 我是一直自学的编程,虽说 Java 基础那块的教程书看了好几遍,但只有写出来的积累到的经验才是真正自己的 . 

**产生原因 :** 当我比较两个 `Long` 类型的数据时使用 == 比较的是其地址 , 两个对象的地址不同当然被判定为永真式 . 对象类型的比对怎么能用 == 判断那 .

**解决方案 :** 1. equals 比较然后取反 

​				  2. 先现实的将其中一个转为 Long 的基本类型 long ,在进行比较

对解决方案很简单,错误也狠脑抽,但是这个问题里涉及到的也无非就是那几个比较基础的问题, 可是这些东西我不是没看过啊,而且不止一遍,八股文都背烂过 .所以拿出来自己思考以下涉及到的东西吧 . 

> 1. 基本类型于引用类型
>
> 2. 包装类的自动拆装箱
>
> 3. 一些编程习惯

###### 为什么使用包装类类型接收参数?

> 在Java中，基本类型在声明时会被赋予默认的初始值，不同类型的基本类型有不同的默认初始值。以下是各个基本类型的默认初始值：
>
> 1. `byte`：0
> 2. `short`：0
> 3. `int`：0
> 4. `long`：0L
> 5. `float`：0.0f
> 6. `double`：0.0d
> 7. `char`：'\u0000'，也就是Unicode编码为0的字符
> 8. `boolean`：false
>
> 这意味着，如果你在声明一个基本类型变量但没有显式地给它赋值，它会被自动赋予上述的默认初始值。例如：
>
> ```
> javaCopy codeint number; // 默认初始值为0
> boolean flag; // 默认初始值为false
> char character; // 默认初始值为'\u0000'
> ```
>
> 需要注意的是，这些默认初始值只适用于类的成员变量和静态变量，对于局部变量而言，在使用之前必须显式地进行赋值，否则编译器会报错。
>
> 基本类型的赋初值是通过Java虚拟机（JVM）在内存分配的过程中实现的。当一个基本类型的变量被声明时，JVM会在栈内存中为其分配一块内存空间，并根据其类型给它赋予一个默认的初值。
>
> 这个过程在JVM的编译和运行时环境中自动进行，程序员不需要显式地为基本类型变量赋初值。这样做的目的是确保基本类型变量在被使用之前都有一个确定的初始值，以避免潜在的不确定性和错误。
>
> 需要注意的是，这种自动赋初值的机制只适用于基本类型，而不适用于引用类型。对于引用类型（例如类、接口、数组等），它们的默认值是`null`，在使用之前需要显式地进行实例化或赋值。

很好,关于基本类型的复制和逻辑我们看不到 . 但是再使用上因为引用类型方便互相转化计算,并且引用类型能 区分有和没有 null 和有数值,

基本类型做成员变量会区分不了这个值是前端传入还是由 jvm 赋值, 所以编程时常用基本类型的包装类做成员变量 .

###### 包装类的自动拆装箱

> Java中的基本数据类型（如int、double、boolean等）与对应的包装类（如Integer、Double、Boolean等）之间可以自动进行装箱和拆箱操作。
>
> 装箱（Boxing）指的是将基本数据类型的值包装到对应的包装类对象中，而拆箱（Unboxing）指的是从包装类对象中获取基本数据类型的值。
>
> 这种自动拆装箱是通过Java编译器在编译时实现的，具体实现如下：
>
> 1. **自动装箱**：当将基本数据类型的值赋给对应的包装类对象时，编译器会自动创建一个包装类对象，并将基本数据类型的值赋给对象的成员变量。
>
>    ```
>    javaCopy codeint num = 42;
>    Integer integer = num; // 自动装箱
>    ```
>
> 2. **自动拆箱**：当需要使用包装类对象中的基本数据类型值时，编译器会自动调用对应的包装类的方法将对象的值提取出来。
>
>    ```
>    javaCopy codeInteger integer = 42;
>    int num = integer; // 自动拆箱
>    ```
>
> 这种自动拆装箱的机制让基本数据类型和包装类之间的转换更加方便，不需要程序员手动进行装箱和拆箱的操作，提高了代码的可读性和简洁性。但在一些性能要求较高的场景，应当注意自动拆装箱可能会引入额外的性能开销。
>
> 自动拆装箱是通过Java编译器在编译时来实现的，它在代码编译过程中对涉及基本类型和包装类型之间的转换进行处理。编译器会在需要自动拆装箱的地方，插入适当的代码以执行拆箱或装箱操作。
>
> 当编译器遇到基本类型和包装类型之间的转换时，它会根据需要插入相应的方法调用来实现拆箱或装箱。例如，在自动拆箱的情况下，编译器会自动调用相应的包装类的 `xxxValue()` 方法，将包装类对象中的值提取出来。
>
> 这些方法调用的实际实现是在包装类的源代码中，而编译器会根据上下文来决定何时插入这些方法调用，以实现自动拆装箱的效果。这种编译器的处理使得程序员在编写代码时无需关心具体的拆装箱操作，从而提高了代码的可读性和易用性。
>
> 需要注意的是，尽管自动拆装箱提供了方便性，但在某些性能敏感的情况下，可能会导致性能开销。因此，在性能要求较高的场景中，建议程序员在适当的时候手动进行拆箱和装箱操作，以避免不必要的性能损失。
>
> 是的，手动拆装箱指的是在代码中显式地调用基本类型和包装类型之间的转换方法，而不是依赖编译器自动插入的方法调用来完成拆装箱操作。
>
> 对于手动拆箱，你需要显式地调用包装类的 `xxxValue()` 方法，将包装类型对象中的值提取出来，例如：
>
> ```
> javaCopy codeInteger integerObj = new Integer(42);
> int intValue = integerObj.intValue(); // 手动拆箱
> ```
>
> 对于手动装箱，你需要显式地调用对应的构造函数或静态工厂方法，将基本类型的值包装成包装类型对象，例如：
>
> ```
> javaCopy codeint intValue = 42;
> Integer integerObj = Integer.valueOf(intValue); // 手动装箱
> ```
>
> 手动拆装箱操作可以在某些性能敏感的场景中提供更好的控制，避免了自动拆装箱可能引起的性能开销。然而，需要注意的是，在一般情况下，编译器的自动拆装箱机制足够满足大多数编程需求，手动拆装箱一般用于特殊情况。
>
> 自动拆装箱是由编译器在编译阶段进行的，而不是在运行时由 JVM 执行的。编译器会根据上下文来判断是否需要进行自动拆装箱操作，并在编译时插入相应的代码来实现拆装箱。这确实可以带来性能上的一些损耗，因为额外的拆装箱操作可能会引起一些开销，特别是在频繁操作基本类型和包装类型之间时。
>
> 然而，在绝大多数情况下，这些性能开销非常小，并且由于代码的可读性和简洁性得到了提高，所以通常不需要过分担心自动拆装箱的性能问题。只有在特定的高性能要求下，或者某些特殊场景下，才需要考虑手动拆装箱以避免潜在的性能损耗。

一句话总结 : 就是吧这是就相当于你不写调用让编译器帮忙调用构造器传值, 实际的包装类的内部还包含一个基本类型,就相当于换了个盒子, 所以才会有 包装类存在 null 的情况,就是盒子存在,里面为空 .